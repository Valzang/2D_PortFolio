bool cPlayer::Update()
{
	Vec2 Pos = GetPos(); 
	if (m_LifeCount < 0)
		return false;


	// 공격 시 뒤로 밀려나게끔
	if (m_AfterAttackTime > 0.f)
	{
		float Back = 100.f;
		if (m_isJumping)
			Back = 200.f;
		if (GetDirection() == 1 && !m_Blocked[(UINT)KEY::LEFT]) // 방향에 따른 이동
			Pos.x -= Back * DELTA_TIME;
		else if (GetDirection() == -1 && !m_Blocked[(UINT)KEY::RIGHT])
			Pos.x += Back * DELTA_TIME;

		m_AfterAttackTime -= DELTA_TIME;
	}
	

	// 플랫폼 위에 없다면 중력
	if (!isOnPlatform())
	{
		Pos.y += m_Dir.y * DELTA_TIME;
		if (m_Dir.y < 800.f)
		{
			if(m_isJumping)
				m_Dir.y += 1200.f * DELTA_TIME;
			else
				m_Dir.y += 250.f * DELTA_TIME;
		}
			
	}

	// 대쉬 중이라면
	if (m_isDashing) 
	{
		if (GetDirection() == -1 && !m_Blocked[(UINT)KEY::LEFT]) // 방향에 따른 이동
			Pos.x -= 400.f * DELTA_TIME;
		else if (GetDirection() == 1 && !m_Blocked[(UINT)KEY::RIGHT])
			Pos.x += 400.f * DELTA_TIME;

		if (m_DashTime >= 0.5) // 0.5초 이상 대시중일 시 초기화
		{
			m_isDashing = false;
			m_DashTime = 0;
			m_isJumping = false;
		}
		else
		{
			m_DashTime += DELTA_TIME;
			m_DashCoolTime += DELTA_TIME;
		}
	}
	else
	{
		if (KEY_CHECK(KEY::I, KEY_STATE::HOLD)) // 실제로 위로 움직이는 게 아닌, 회전 플랫폼에 있을 때 위쪽으로 회전시키는 용도로만 쓰임.
		{
			Pos.y -= 200.f * DELTA_TIME;
		}
		if (KEY_CHECK(KEY::K, KEY_STATE::HOLD)) // 아래를 짚음.
		{
			m_isSitted = true;
			if (KEY_CHECK(KEY::S, KEY_STATE::DOWN) && m_DashCoolTime > 0.55 && !m_isJumping) // 여기서 대쉬하면서 이동을 빠르게 해야함.
			{
				m_isMoved = false;
				m_isDashing = true;
				m_DashCoolTime = 0;
				m_DashTime = 0;
			}
		}
		if (KEY_CHECK(KEY::K, KEY_STATE::UP) || KEY_CHECK(KEY::K, KEY_STATE::NONE))
		{
			m_isSitted = false;
		}

		if (KEY_CHECK(KEY::S, KEY_STATE::DOWN) && !m_isJumping && !m_isSitted && !m_isDashing && isOnPlatform())
		{
			m_isJumping = true;
			m_Dir.y *= -1;
			SetOnPlatform(false);
		}

		// ============================================= 좌측 이동
		if (KEY_CHECK(KEY::J, KEY_STATE::DOWN) && (KEY_CHECK(KEY::L, KEY_STATE::UP) || KEY_CHECK(KEY::L, KEY_STATE::NONE)) && m_AfterAttackTime <= 0.f && !m_Blocked[(UINT)KEY::LEFT])
		{
			if (!m_isDashing)
				m_isMoved = true;
			SetDirection(-1);
			m_Blocked[(UINT)KEY::RIGHT] = false;
		}
		if (KEY_CHECK(KEY::J, KEY_STATE::HOLD) &&(KEY_CHECK(KEY::L, KEY_STATE::UP) || KEY_CHECK(KEY::L, KEY_STATE::NONE)) && m_AfterAttackTime <= 0.f && !m_Blocked[(UINT)KEY::LEFT])
		{
			if (!m_isDashing)
				m_isMoved = true;
			Pos.x -= 250.f * DELTA_TIME;
			SetDirection(-1);
			m_Blocked[(UINT)KEY::RIGHT] = false;
		}
		if (KEY_CHECK(KEY::J, KEY_STATE::UP))
		{
			m_isMoved = false;
		}

		// ============================================= 우측 이동
		if (KEY_CHECK(KEY::L, KEY_STATE::DOWN) && (KEY_CHECK(KEY::J, KEY_STATE::UP) || KEY_CHECK(KEY::J, KEY_STATE::NONE)) 
			&& m_AfterAttackTime <= 0.f && !m_Blocked[(UINT)KEY::RIGHT])
		{
			if(!m_isDashing)
				m_isMoved = true;
			SetDirection(1);
			m_Blocked[(UINT)KEY::LEFT] = false;
		}
		if (KEY_CHECK(KEY::L, KEY_STATE::HOLD) && (KEY_CHECK(KEY::J, KEY_STATE::UP) || KEY_CHECK(KEY::J, KEY_STATE::NONE)) 
			&& m_AfterAttackTime <= 0.f && !m_Blocked[(UINT)KEY::RIGHT])
		{
			if (!m_isDashing)
				m_isMoved = true;
			Pos.x += 250.f * DELTA_TIME;
			SetDirection(1);
			m_Blocked[(UINT)KEY::LEFT] = false;
		}
		if (KEY_CHECK(KEY::L, KEY_STATE::UP))
		{
			m_isMoved = false;
		}

		// ============================================= 폭탄 설치
		if (KEY_CHECK(KEY::A, KEY_STATE::DOWN))
		{
			if (m_AtkCoolTime >= 1.5f)
			{
				m_AtkCoolTime = 0.f;
				if (m_isJumping)
					m_AfterAttackTime = 0.3f;
				else
					m_AfterAttackTime = 0.1f;
				CreateBomb();
			}
		}
		m_AtkCoolTime += DELTA_TIME;
		m_DashCoolTime += DELTA_TIME;
	}

	if(m_Dir.y >= 0.f)
	{
		Vec2 Scale = GetScale();
		Collsion(*this,(UINT)GROUP_TYPE::PLATFORM, 1.f);
	}
	if (isOnPlatform())
	{
		m_Dir.y = 450.f;
		m_isJumping = false;
	}

	SetPos(Pos);
	SetPosOtherside(); // 반대쪽으로 넘어갔으면 다른 쪽으로 나오게끔

	return true;
}